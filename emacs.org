#+title: .emacs in Org
#+PROPERTY: header-args :tangle "~/.emacs"

* Setup
  Initial setup.
#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

  Manually specify file (to store into and load from) the customize variable so that it does not clobber the `.emacs` file.
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+END_SRC

  Load EXWM if needed.
  TODO: Clean up this filename repetition in this entire file.
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
(require 'exwm)
(require 'exwm-config)
(exwm-enable)
#+END_SRC
* Packages
  Specifying and installing packages.
  
** Setup package and melpa.
#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-check-signature nil)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/"))
(package-initialize)
#+END_SRC
** Quelpa
   Install "Quelpa" for those corner case packages not on Melpa. For now, stuff on github.
#+BEGIN_SRC emacs-lisp
  ;; (require 'quelpa)
#+END_SRC
** Install packages
Right now, manually installed.

Bring in `use-package` here.
* Evil is Good
  In this section, I do everything I possibly can to make emacs edit like Vim. 
  I might have started living in Emacs, but I am not leaving Vim behind.
  
  Core install.
#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :config
  (evil-mode 1))
#+END_SRC

** Basic Vim compatibility

  Number control like in vim. Note how we bind decrement to C-S-a. Can't use C-x, that's why.
#+BEGIN_SRC emacs-lisp
(use-package evil-numbers
  :ensure t
  :bind (:map evil-normal-state-map
         ("C-a" . evil-numbers/inc-at-pt)
	 ("C-S-a" . evil-numbers/dec-at-pt)))
#+END_SRC

  Relative line numbering. Activate only for programming related buffers.
#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type 'relative)
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
#+END_SRC

  Show matching paranthesis (and other brackets).
#+BEGIN_SRC emacs-lisp
(show-paren-mode)
#+END_SRC

  TODO Complete file names.
#+BEGIN_SRC emacs-lisp
#+END_SRC

  Jump using \*/\# uses symbols in Vim. In evil, it defaults to use word under cursor, which is not too helpful.
#+BEGIN_SRC emacs-lisp
(evil-define-motion evil-search-symbol-backward (count)
  "Simply pass in true for the symbol param of the original motion."
  (evil-search-word-backward count t))
(define-key evil-motion-state-map "#" 'evil-search-symbol-backward)

(evil-define-motion evil-search-symbol-forward (count)
  "Simply pass in true for the symbol param of the original motion."
  (evil-search-word-forward count t))
(define-key evil-motion-state-map "*" 'evil-search-symbol-forward)
#+END_SRC

  Don't prompt for jumping to files using gf.
#+BEGIN_SRC emacs-lisp
  (defun ffap-noprompt ()
    "Repackaged ffap that guesses the file under string and jumps to it if possible. Does nothing if nothing useful is found. Does not prompt the user in any case."
    (interactive)
    (let ((file-guess (ffap-guess-file-name-at-point)))
      (if (equal "~/" file-guess)
        (message "No file found under cursor.")
        (find-file file-guess))))

  (define-key evil-normal-state-map "gf" 'ffap-noprompt)
#+END_SRC
** For general editing
  Commentary available as `evil-commentary`.
#+BEGIN_SRC emacs-lisp
(use-package evil-commentary
  :ensure t
  :bind (:map evil-normal-state-map
         ("gc" . evil-commentary)
         ("gy" . evil-commentary-yank)))
#+END_SRC

  Quickscope port. Only activates upon pressing f/F/t/T.
#+BEGIN_SRC emacs-lisp
(use-package evil-quickscope
  :ensure t
  :config
  (global-evil-quickscope-mode 1))
#+END_SRC

  Bindings for "flycheck".
#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map "]f" 'flycheck-next-error)
(define-key evil-normal-state-map "[f" 'flycheck-previous-error)
#+END_SRC

** General text objects
   Yank to end of line with Y.
#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map (kbd "Y") (kbd "y$"))
#+END_SRC

   Targets/TextObjectify style seek behaviour for text objects.
#+BEGIN_SRC emacs-lisp
  ;; (quelpa '(targets :fetcher git :url "https://github.com/noctuid/targets.el"))
  (targets-setup t)
#+END_SRC

  ReplaceWithRegister port. Works fine.
#+BEGIN_SRC emacs-lisp
(use-package evil-replace-with-register
  :ensure t
  :config
  (setq evil-replace-with-register-key (kbd "gr"))
  (evil-replace-with-register-install))
#+END_SRC

  Generic function text object. Not really tested with counts etc. Only have a "a" type. Inner/Outer seem to vary with language
  too much.
#+BEGIN_SRC emacs-lisp
  (evil-define-text-object evil-a-function (count &optional beg end type)
     (evil-range (save-excursion
                   (beginning-of-defun) (point))
                 (save-excursion
                   (end-of-defun) (point))
                 ; force line-wise mode
                 'line))

  (define-key evil-outer-text-objects-map "f" 'evil-a-function)
#+END_SRC

  Function Arguments text object.
#+BEGIN_SRC emacs-lisp
  (use-package evil-args
     :ensure t
     :bind (:map evil-inner-text-objects-map
            ("a" . evil-inner-arg)
	    :map evil-outer-text-objects-map
            ("a" . evil-outer-arg)
	    ;; bind evil-forward/backward-args
	    :map evil-normal-state-map
	    ("]a" . evil-forward-arg)
	    ("[a" . evil-backward-arg)))
#+END_SRC

  Indent based text object.
#+BEGIN_SRC emacs-lisp
(use-package evil-indent-plus
  :ensure t
  :config
  (evil-indent-plus-default-bindings))
#+END_SRC

  Using embrace for surround.
  TODO -> allow cancelling using 'esc
#+BEGIN_SRC emacs-lisp
(use-package embrace
  :ensure t
  :bind (:map evil-normal-state-map
         ("s" . embrace-commander)))
#+END_SRC

  Exchange.
#+BEGIN_SRC emacs-lisp
  (use-package evil-exchange
    :ensure t
    :config
    (evil-exchange-install))
#+END_SRC

  Expand region from Visual.
  #+begin_src emacs-lisp
(define-key evil-visual-state-map (kbd "v") 'er/expand-region)
  #+end_src
  
** Version Control
   
   Git gutter.
#+BEGIN_SRC emacs-lisp
(use-package git-gutter+
  :ensure t
  :config
  (global-git-gutter+-mode)
  :bind (:map evil-normal-state-map
         ("]c" . git-gutter+-next-hunk)
         ("[c" . git-gutter+-previous-hunk)))
#+END_SRC 

  Hunk text object.
#+BEGIN_SRC emacs-lisp
(defun pos-from-line (line)
  (save-excursion 
   (goto-char (point-min))
   (forward-line line)
   (point)))
   
(evil-define-text-object evil-inner-githunk (count &optional beg end type)
  (setq di (git-gutter+-diffinfo-at-point))
  (setq start (plist-get di :start-line))
  (setq end (plist-get di :end-line))
  (evil-range (pos-from-line (- start 1)) (pos-from-line end) type :expanded t))
    
(define-key evil-inner-text-objects-map "h" 'evil-inner-githunk)
#+END_SRC
** For Orgmode
#+BEGIN_SRC emacs-lisp
(use-package evil-org
  :ensure t)
(use-package s
  :ensure t)

(require 's)
(require 'evil-org)
(add-hook 'org-mode-hook 'evil-org-mode)
(evil-org-set-key-theme '(navigation insert textobjects additional calendar))
#+END_SRC
** Emacs pecularities
   Use `q` for closing buffers instead of frames. Setup `Q` to close frames.
 #+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "q" 'kill-this-buffer)
(evil-ex-define-cmd "Q" 'evil-quit)
 #+END_SRC

   Unbind "M-." which is used for finding definitions (esp useful in Slime):
   #+begin_src emacs-lisp
  (define-key evil-normal-state-map (kbd "M-.") nil)
   #+end_src
** Disable evil for special buffers
   #+begin_src emacs-lisp
   (evil-set-initial-state 'xref--xref-buffer-mode 'emacs)
   #+end_src

   For process mode:
   #+begin_src emacs-lisp
   (evil-set-initial-state 'process-mode 'emacs)
   #+end_src

   For shells:
   #+begin_src emacs-lisp
(evil-set-initial-state 'shell-mode 'emacs)
(evil-set-initial-state 'eshell-mode 'emacs)
(evil-set-initial-state 'vterm-mode 'emacs)
   #+End_src

   For other buffers:
   #+begin_src emacs-lisp
(evil-set-initial-state 'eww-mode 'emacs)
(evil-set-initial-state 'eww-buffers-mode 'emacs)
   #+end_src
* Leader Key-like
  These are assorted one shot shortcuts prefixed using ";".

  Shortcut for `find-file`.
#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map (kbd ";f") 'find-file)
#+END_SRC

  Switch to alternate file.
#+begin_src emacs-lisp
(define-key evil-normal-state-map (kbd "ga") 'ff-find-other-file)
#+end_src

  Easier keys for the in-built bookmarking system. Mainly used to jump between projects.
#+begin_src emacs-lisp
(define-key evil-normal-state-map (kbd ";b") 'bookmark-jump)
(define-key evil-normal-state-map (kbd ";B") 'bookmark-set)
#+end_src

  Custom shortcuts for important files:
#+begin_src emacs-lisp
(define-key evil-normal-state-map (kbd ";t") (lambda () (interactive) (find-file "~/orgmode/todo.org")))
(define-key evil-normal-state-map (kbd ";c") (lambda () (interactive) (find-file "~/Customization/dotfiles/emacs.org")))
#+end_src

  Easily access `remember-mode`:
#+begin_src emacs-lisp
  (define-key evil-normal-state-map (kbd ";r") 'remember)
  (define-key evil-visual-state-map (kbd ";r") (lambda ()
                                                  (interactive)
                                                  (let ((current-prefix-arg 4))
                                                    (call-interactively 'remember))))

  (define-key evil-normal-state-map (kbd ";R") 'remember-notes)
#+end_src
* Emacs rocks
  Assorted emacs packages and configurations too small to go as separate configurations.
** Company
   The issue here is that the evil completion functions don't have pop-ups. Company is it's own thing, does not
   come with Vim like completion out of the box. This is an attempt to unify the two approaches into a more
   Vim like experience.

   Cycle through options like in Vim.
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t)
(with-eval-after-load 'company
  (define-key company-active-map (kbd "C-n") (lambda () (interactive) (company-complete-common-or-cycle 1)))
  (define-key company-active-map (kbd "C-p") (lambda () (interactive) (company-complete-common-or-cycle -1))))
#+END_SRC

   Company backend to complete whole lines from the current buffer.
#+BEGIN_SRC emacs-lisp
  (use-package cl-lib
    :ensure t)
  
  (require 'cl-lib)
  (require 'company)
  (require 's)

  (defun company-whole-lines (command &optional arg &rest ignored)
    "Complete whole lines from current buffer."
    (interactive (list 'interactive))

    (cl-case command
      (interactive (company-begin-backend 'company-whole-lines))
      (prefix (buffer-substring-no-properties (line-beginning-position) (point)))
      (candidates
        (cl-remove-if-not
          (lambda (c) (s-starts-with? arg c))
          (split-string (buffer-substring-no-properties (point-min) (point-max)) "\n")))))
#+END_SRC

   Setting up the backends to specific keys.
#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'global-company-mode)
(company-mode +1)
; proper Vim like file completion
(define-key evil-insert-state-map (kbd "C-x C-f") 'company-files)
; whole line completion
(define-key evil-insert-state-map (kbd "C-x C-l") 'company-whole-lines)
; C-n and C-p now do the same thing: words from all buffers based on dabbrev
; this is not exactly like in Vim, but it's a start
(define-key evil-insert-state-map (kbd "C-n") 'company-dabbrev-code)
(define-key evil-insert-state-map (kbd "C-p") 'company-dabbrev-code)
#+END_SRC

** Magit

   Easier bind to access `magit-status` panel:
   #+begin_src emacs-lisp
   (define-key evil-normal-state-map (kbd ";g") 'magit-status)
   #+end_src

   Also bind a simple key for single file dispatch:
   #+begin_src emacs-lisp
      (define-key evil-normal-state-map (kbd ";G") 'magit-file-dispatch)
      (define-key evil-visual-state-map (kbd ";G") 'magit-file-dispatch)
   #+end_src

   Easy access to commit history of specific lines:
   #+begin_src emacs-lisp
     (define-key evil-visual-state-map (kbd ";gl") 'magit-log-buffer-file)
   #+end_src

  Set default state for magit commit mode to normal.
#+BEGIN_SRC emacs-lisp
(add-hook 'git-commit-mode-hook 'evil-normal-state)
#+END_SRC

  The new transient mechanism drops the `q` command to quit. That's bad, I need my `q`.
  This new `q` only kills the latest transient, we can use `C-q` to take out all transients.
  Source: [[https://magit.vc/manual/transient.html#Aborting-and-Resuming-Transients][Transients]]
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'transient
    (transient-bind-q-to-quit))
#+END_SRC
** Dimnish
   Manually dimnish modes until we get everything onto use-package.
#+BEGIN_SRC emacs-lisp
(use-package diminish
  :ensure t
  :config
  (diminish 'helm-mode)
  (diminish 'auto-revert-mode)
  (diminish 'evil-org-mode)
  (diminish 'undo-tree-mode)
  (diminish 'global-undo-tree-mode)
  (diminish 'git-gutter+-mode)
  (diminish 'global-git-gutter+-mode))
#+END_SRC
** Cyphejor
   Minimizing mode-line space wastage.
#+BEGIN_SRC emacs-lisp
(use-package cyphejor
  :ensure t)

(setq
 cyphejor-rules
 '(:upcase
   ("buffer"      "β")
   ("diff"        "Δ")
   ("dired"       "δ")
   ("emacs"       "ε")
   ("inferior"    "i" :prefix)
   ("interaction" "i" :prefix)
   ("interactive" "i" :prefix)
   ("lisp"        "λ" :postfix)
   ("menu"        "▤" :postfix)
   ("mode"        "")
   ("package"     "↓")
   ("python"      "π")
   ("shell"       "sh" :postfix)
   ("text"        "ξ")
   ("wdired"      "↯δ")
   ("company"     "⇔")
   ("projectile"  "P")
   ("helm"        "H")))
   
(cyphejor-mode 1)
#+END_SRC
** Gtags
   ggtags in emacs speak.

   Find references or definition. Better than the vim version.
#+BEGIN_SRC emacs-lisp
;;(define-key evil-normal-state-map (kbd "C-]") 'ggtags-find-tag-dwim)
#+END_SRC
   Deprecated in favor of dumb-jump.
** Occur

  Easier occur.
#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map (kbd "C-l") 'occur)
#+END_SRC

  Allow easy copying of lines from the Occur buffer.
#+begin_src emacs-lisp
(defun occur/copy-curr-line ()
   (interactive)
   (let* ((rawline (buffer-substring-no-properties (line-beginning-position) (line-beginning-position 2)))
          (line (string-trim-left rawline "[ 0-9]+:")))
     (kill-new line)
     (message "Copied current line.")))

(define-key occur-mode-map "y" 'occur/copy-curr-line)
#+end_src

** Emacs is good for editing too!
  Emacs paradigms for editing.

  Configuring tabs.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq tab-width 4)
#+END_SRC  

  Automatic trailing white-space management
#+BEGIN_SRC emacs-lisp
  ;; (use-package ws-butler
  ;;   :ensure t
  ;;   :hook (prog-mode org-mode))
#+END_SRC

  Complete at point.
#+BEGIN_SRC emacs-lisp
(define-key evil-insert-state-map (kbd "C-/") 'completion-at-point)
#+END_SRC

  Undo in visually selected region:
#+begin_src emacs-lisp
(define-key evil-visual-state-map (kbd "u") 'undo)
#+end_src

** eww
   Is just awesome.

   Setup Readable mode for some websites.
   #+begin_src emacs-lisp
     (with-eval-after-load 'eww
       (add-hook 'eww-after-render-hook 'cg/eww-readable))
   #+end_src

   #+begin_src emacs-lisp
     (defun cg/eww-readable ()
       (let ((url (eww-current-url)))
         (cond ((string-match "scholar.google.com" url)
         )
       )))
   #+end_src

   Special binding to download to directory of the last buffer.
   #+begin_src emacs-lisp
     (defun cg/eww-download-local ()
       (interactive)
       (let* ((pbuffer (other-buffer (current-buffer) t))
              (dir (with-current-buffer pbuffer default-directory))
              )
         (setq eww-download-directory dir)
         (eww-download)
         (dired dir)
         ))

     (with-eval-after-load 'eww
       (define-key eww-mode-map (kbd "D") 'cg/eww-download-local))
   #+end_src
** pdf-tools
   Enable pdf-tools.
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :ensure t
    :config
    (pdf-tools-install)
    :bind (:map pdf-view-mode-map
           ("C-G" . pdf-view-first-page)
           ("G" . pdf-view-last-page)
           ("^" . switch-to-prev-buffer)
           ("t" . image-bob)
           ("S" . pdftools/search-in-scholar)
           ("y" . pdf-view-kill-ring-save)
           ("hh" . pdf-annot-add-highlight-markup-annotation)
           ("hs" . pdf-annot-add-squiggly-markup-annotation)
           ("hu" . pdf-annot-add-underline-markup-annotation)
           ("hc" . pdf-annot-add-strikethrough-markup-annotation)
           ("T" . pdf-annot-add-text-annotation)
  ))
#+END_SRC

Force use of pdf-tools when opening from eww:
#+begin_src emacs-lisp
(add-to-list 'mailcap-user-mime-data
               '((type . "application/pdf")
                 (viewer . pdf-view-mode)))
#+end_src

  Search the selected text on google scholar - useful only in references section.
#+begin_src emacs-lisp
  (defun pdftools/search-in-scholar ()
    "Search selected text on Google scholar."
    (interactive)
    (let* ((phrase (car (pdf-view-active-region-text)))
           (query (url-encode-url phrase))
           (url (concat "https://scholar.google.com/scholar?hl=en&q=" query)))
      (select-frame (make-frame))
      (eww url)))
#+end_src
** Torus
  Enable tab bar, configure some shortcuts.
#+BEGIN_SRC emacs-lisp
(use-package torus
  :bind-keymap ("s-t" . torus-map)
  :bind (("<C-next>" . torus-next-location)
         ("<C-prior>" . torus-previous-location)
         ("<C-b>" . torus-switch-location)
         :map torus-map)
  :custom ((torus-prefix-key "s-t")
           (torus-display-tab-bar t))
  :config
  (torus-init)
  (torus-install-default-bindings))

(define-key evil-normal-state-map (kbd "<C-b>") 'torus-switch-location)
#+END_SRC
** Dired
   Use ~dired-ranger~ to provide an intuitive and much simpler copy paste of files from dired. (Esp useful over Tramp)
#+begin_src emacs-lisp
  (use-package dired-ranger
    :ensure t
    :init (setq dired-dwim-target t)
    :bind (:map dired-mode-map
                ("W" . dired-ranger-copy)
                ("X" . dired-ranger-move)
                ("Y" . dired-ranger-paste)))
#+end_src

   Bind simple "e" to go into wdired.
#+begin_src emacs-lisp
(eval-after-load 'dired-mode
  '(define-key dired-mode-map "e" 'wdired-change-to-wdired-mode))
#+end_src

   Quick download files from dired.
#+begin_src emacs-lisp
  (defun dired/download-file (url name)
    (interactive (list
                   (read-string "Url: " (substring-no-properties (gui-get-selection)))
                   (read-string "Save as: " ".pdf")
                  ))
    (url-copy-file url name)
    (revert-buffer)
  )

  (eval-after-load 'dired-mode
    '(define-key dired-mode-map "p" 'dired/download-file))
#+end_src
** Tramp
   Use ssh config to pick Tramp targets. Uses external finder for now.
#+begin_src emacs-lisp
(defun cg/tramp-to ()
  "Open tramp to remote host"
  (interactive)
  (let ((host (s-chomp (shell-command-to-string "grep ^Host ~/.ssh/config | awk '{print $2}' | dmenu -i -l 10 -p 'ssh to>'"))))
    (find-file (concat "/ssh:" host ":"))))
#+end_src
** WhichKey
#+begin_src emacs-lisp
(use-package which-key
  :ensure t
  :config
  (which-key-mode))
#+end_src
** Dumb Jump
#+begin_src emacs-lisp
(use-package dumb-jump
  :ensure t
  :config
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
  (define-key evil-normal-state-map (kbd "C-]") 'xref-find-definitions)
)
#+end_src
** Projectile

   Base configuration.
 #+begin_src emacs-lisp
   (use-package projectile
     :ensure t
     :init
     (projectile-mode +1)
     (setq projectile-switch-project-action #'projectile-dired)
     :bind (:map projectile-mode-map
            ("M-p" . projectile-command-map)))
#+end_src

  Add `helm-projectile`.
#+begin_src emacs-lisp
(use-package projectile
  :ensure t)
#+end_src

  One-shot keybindings
#+begin_src emacs-lisp
  (define-key evil-normal-state-map (kbd "'p") 'projectile-switch-project)
  (define-key evil-normal-state-map (kbd "'P") 'projectile-add-known-project)

  (define-key evil-normal-state-map (kbd "'f") 'helm-projectile-find-file)
  (define-key evil-normal-state-map (kbd "'b") 'helm-projectile-switch-to-buffer)

  (define-key evil-normal-state-map (kbd "'g") 'helm-projectile-grep)
#+end_src
** Ediff
   #+begin_src emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
   #+end_src
* Organizing Org
  
  Global calls. Need to revisit and clean up.
#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
(global-set-key "\C-cb" 'org-iswitchb)
#+END_SRC

  Syntax highlight code blocks.
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

  Auto update clock tables and dynamic blocks on save.
  ONLY for org buffers. This was causing a *lot* of problems when I had set them to global hooks.
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
  (lambda ()
        (add-hook 'before-save-hook 'org-update-all-dblocks)
        (add-hook 'before-save-hook 'org-table-recalculate-buffer-tables)
        (add-hook 'auto-save-hook 'org-update-all-dblocks)
        (add-hook 'auto-save-hook 'org-table-recalculate-buffer-tables)))
#+END_SRC

  Zoom in and out of headings.
#+BEGIN_SRC emacs-lisp
(eval-after-load 'org-mode
    '(define-key org-mode-map (kbd "C-<next>") (lambda ()
				   (interactive)
				   (outline-next-visible-heading 0)
				   (org-narrow-to-subtree))))

(eval-after-load 'org-mode
    '(define-key org-mode-map (kbd "C-<prior>") (lambda ()
				    (interactive)
				    (widen)
				    (outline-up-heading 1)
				    (org-narrow-to-subtree))))
#+END_SRC

  No confirm shell links for nice button like behaviour.
#+BEGIN_SRC emacs-lisp
(setq org-confirm-shell-link-function nil)
#+END_SRC

  Set agenda view sizes.
#+BEGIN_SRC emacs-lisp
(setq org-agenda-window-frame-fractions '(0.25 . 0.40))
#+END_SRC

  For snippets.
#+BEGIN_SRC emacs-lisp
(require 'org-tempo)
#+END_SRC

** Clocking
   Add completion time to tasks.
#+BEGIN_SRC emacs-lisp
(setq org-log-done 'time)
#+END_SRC

  Functions for Pomodoro with tasks.
#+BEGIN_SRC emacs-lisp
(defun pomodoro-start ()
  "Starts and automatically clocks out a Pomodoro unit of x minutes."
  (interactive)
  (if (org-clocking-p)
    (if (get-process "pomodoro")
      (kill-process "pomodoro")
      (org-clock-out))
    (progn
        (org-clock-in)
        (let ((x (read-string "Time (in min): ")))
            (message (format "Starting pomodoro cycle of %s minutes." x))
            (set-process-sentinel (start-process "pomodoro" nil "sleep" (format "%sm" x)) 'pomodoro-end)))))

(global-set-key (kbd "<print>") 'pomodoro-start)

(defun pomodoro-end (process event)
  (org-clock-out)
  (message "Stopping pomodoro cycle.")
  (start-process "herbe" nil "herbe" "Pomodoro done."))
#+END_SRC

#+begin_src emacs-lisp
;; (global-set-key (kbd "<print>") (lambda ()
;; 			(interactive)
;; 			(if (org-clocking-p)
;; 			  (org-clock-out)
;; 			  (org-clock-in)
;; 			)))
#+end_src
** Babel
  Active Babel languages.
#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((python . t)
   (emacs-lisp . t)
   (dot . t)
   (C . t)
   (shell . t)
   (gnuplot . t)
   ))
#+END_SRC

  Setup python3.
  #+begin_src emacs-lisp
  (setq org-babel-python-command "python3")
  #+end_src

  Disable confirmation upon C-c C-c.
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC 

  Notify after execution of source blocks finish.
#+BEGIN_SRC emacs-lisp
(add-hook 'org-babel-after-execute-hook (lambda ()
					  (interactive)
					  (start-process "Notification" nil "notify-send" "Emacs" "Evaluation of src block finished.")
						))
#+END_SRC

  Get async execution.
#+BEGIN_SRC emacs-lisp
(use-package ob-async
  :ensure ob-async)
#+END_SRC
** Todos

Better colors.
#+BEGIN_SRC emacs-lisp
(setq org-todo-keyword-faces
  '(("BLOCKED" . "yellow")))
#+END_SRC
** Agenda

   More agenda views.
#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
  '(("x" todo-tree "TODO")))
#+END_SRC
** Tables
   When exporting data, mutli-row cells are a bit unwieldly. Best option is to create new rows, making it look like a pseudo cell.
   You will then need to insert row separators.

   After all this, the html export will look ugly, due to spacing issues. Use the below css to clean it up:
#+BEGIN_EXAMPLE
td {
  padding: 0px;
  padding-right: 15px;
  padding-left: 15px;
}

tbody::before{
  content: '';
  display: block;
  height: 5px;
}

tbody::after{
  content: '';
  display: block;
  height: 5px;
}
#+END_EXAMPLE
** Orgish

   #+begin_src emacs-lisp
     (load "~/Documents/Dabblings/orgish/orgish")
   #+end_src
** Org-download
   #+begin_src 
(require 'org-download)
(setq org-download-method 'attach)
(setq org-image-actual-width '(600))
   #+end_src
* LaTeX setup
  
  Path setup for TeXLive binaries.
#+BEGIN_SRC emacs-lisp
(setenv "PATH" (concat (getenv "PATH") ":" (expand-file-name "/usr/local/texlive/2018/bin/x86_64-linux")))
(add-to-list 'exec-path "/usr/local/texlive/2018/bin/x86_64-linux")
#+END_SRC

  Basic AucTeX setup.
#+BEGIN_SRC emacs-lisp
(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq-default TeX-master nil)
#+END_SRC

  Open using PDF tools.
#+BEGIN_SRC emacs-lisp
(setq TeX-view-program-selection '((output-pdf "PDF Tools"))
      TeX-source-correlate-start-server t)

(add-hook 'TeX-after-compilation-finished-functions
           #'TeX-revert-document-buffer)

(add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
#+END_SRC

  Also use reftex.
#+BEGIN_SRC emacs-lisp
(add-hook 'LaTeX-mode-hook 'turn-on-reftex)
#+END_SRC

  Evil objects for latex.
#+BEGIN_SRC emacs-lisp
  ;; (quelpa '(evil-latex-textobjects :fetcher git :url "https://github.com/hpdeifel/evil-latex-textobjects"))
  (require 'evil-latex-textobjects)
  (add-hook 'LaTeX-mode-hook 'turn-on-evil-latex-textobjects-mode)
#+END_SRC
* General Programming helpers
** Find/Replace
   General programmatic full buffer case-sensitive find/replace strings.
#+BEGIN_SRC emacs-lisp
(defun cg/replace-all (from to)
  (let ((case-fold-search nil))
    (goto-char (point-min))
    (while (search-forward from nil t)
      (replace-match to))))
#+END_SRC
** TODO Anisble
*** Run the task under the cursor. (Possible tag it using an unique tag and run ansible and then get back.)
   1. Setup keybindings as a minor mode (maybe based on evil).
   2. Pick up inventory file from nearest folder.
   3. Tag the current set of tasks and add the tag to ansible command.
   4. Run the file directly (???)
   5. Untag the set of tasks.

*** General transient based UI for Anisble to select tags etc
    Can also take the tag/task under cursor directly if possible.
*** Task/Play text objects
** TODO Delete lines matching regex in entire project
   1. flush-lines does this for a single file.
   2. Interactive ways include:
      - Run multi-occur and then occur-edit. There is no clear delete this line feature though.
      - Run grep, then use wgrep mode to delete lines. (Need to pick up the wgrep related config from evil-collection to allow evil keybindings inside of the grep buffer.)
** Toggle boolean in line
   Shamelessly taken from [[https://www.reddit.com/r/emacs/comments/4nq704/cycle_between_truefalse_and_other_arbitrary_pairs/d486xwn/][here]] and modified to work. Don't fully understand, may need to simplify one day.
#+BEGIN_SRC emacs-lisp
(defun cg/toggle-boolean ()
  "Toggle any booleans found on the current line."
  (interactive)
  (let ((booleans (ht ("true" "false")
                      ("false" "true")
                      ("True" "False")
                      ("False" "True"))))
    (save-excursion
      (save-restriction
        (narrow-to-region (point-at-bol) (point-at-eol))
        (setq toggle-boolean-re (-reduce (lambda (memo item) (format "%s\\|%s" memo item)) (ht-keys booleans)))
        (goto-char (point-min))
        (re-search-forward toggle-boolean-re nil t))
      (let* ((thing2 (thing-at-point 'word))
             (bounds (bounds-of-thing-at-point 'word))
             (pos1 (car bounds))
             (pos2 (cdr bounds)))
        (setq replacement (ht-get booleans thing2 nil))
        (when replacement
          (delete-region pos1 pos2)
          (insert replacement))))))

; who uses - or _ anyway
(define-key evil-normal-state-map (kbd "_") 'cg/toggle-boolean)
#+END_SRC
** Swap comment with main text
   Oddly specific function that does only 1 thing under the most specific circumstances.
   Assumes that you are on a line with the following line being commented out. What it does is, comment out the current line and uncomment the following line and switches them around.
#+BEGIN_EXAMPLE
# Initial state
mode = "abc"
# mode = "def"

# With cursor anywhere on the first line, becomes
mode = "def"
# mode = "abc"
#+END_EXAMPLE

  Why is this important you ask? Meant for toggling between 2 options quickly, as it often happens in bash scripts and the like.

#+BEGIN_SRC emacs-lisp
(defun cg/transpose-and-toggle-comment ()
  (interactive)
  (save-excursion (comment-line 1) (comment-line 1))
  (save-excursion (transpose-lines 1)))

(define-key evil-normal-state-map "+" 'cg/transpose-and-toggle-comment)
#+END_SRC
** Convert lines into a double quoted list
   #+begin_src emacs-lisp
(defun lines-to-cslist (start end &optional arg)
  (interactive "r\nP")
  (let ((insertion
         (mapconcat 
          (lambda (x) (format "\"%s\"" x))
          (split-string (buffer-substring start end)) ", ")))
    (delete-region start end)
    (insert insertion)
    (when arg (forward-char (length insertion)))))
   #+end_src
** Randomize a list of comma separated items
   #+begin_src emacs-lisp
  (defun randomize-comma-separated-list (start end)
    "Randomize order of the comma separated list in the region."
    (interactive "r")
    (let ((str (mapconcat 'identity
			  (sort (split-string (replace-regexp-in-string
					       "\\s-+" " "
					       (buffer-substring start end))
					      " ?, ?" t)
				(lambda (a b) (= 1 (random 2))))
			  ", ")))
      (delete-region start end)
      (insert str)))
   #+end_src
* Elisp functions/snippets to smoothen workflows
  Custom function to delete all buffers.
#+BEGIN_SRC emacs-lisp
(defun cg/kill-all-buffers ()
  (interactive)
  (mapc 'kill-buffer (buffer-list)))
#+END_SRC

  Display current buffer name.
#+BEGIN_SRC emacs-lisp
(defun cg/display-file-name ()
  (interactive)
  (message (buffer-file-name)))
#+END_SRC
* Programming language/platform specifics
** C
#+begin_src emacs-lisp
  (evil-define-key 'normal 'c-mode-map (kbd "'c") 'recompile)

#+end_src
** Golang
   Get go related binaries into path.
#+BEGIN_SRC emacs-lisp
(add-to-list 'exec-path (expand-file-name "~/thirdparty/go/bin"))
(add-to-list 'exec-path (substitute-in-file-name "$GOPATH/bin"))
(add-to-list 'exec-path (expand-file-name "~/go/bin"))
#+END_SRC

  Using flycheck (w/ go-metalinter) for linting.

  Setup stuff for go-mode.
#+BEGIN_SRC emacs-lisp
(defun go-mode-addons ()
  ; syntax checking/linter
  (flycheck-mode)
  ; startup lsp client HERE
  ;(lsp)
  (lsp-ui-mode)
  ; auto goimport on save
  (setq gofmt-command "goimports")
  (add-hook 'before-save-hook 'gofmt-before-save)
  ; autocomplete
  (require 'company)
  (require 'company-go)
  (set (make-local-variable 'company-backends) '(company-go))
  (company-mode)
  ; documentation
  (go-eldoc-setup)
  ; for auto expanding abbrevations
  (define-abbrev go-mode-abbrev-table "ife" "" 'golang-err-skeleton)
  (abbrev-mode 1))

(add-hook 'go-mode-hook #'go-mode-addons)
#+END_SRC

  Skeleton + abbrev for snippets.
#+BEGIN_SRC emacs-lisp
(define-skeleton golang-err-skeleton
  "The usual error checking construct"
  nil
  "if err != nil {"\n
  >"return " _ \n
  "}" > \n)

#+END_SRC

  Alternative Setup
  #+begin_src emacs-lisp
    (use-package go-mode
      :mode "\\.go\\'"
      :config
      (defun my/go-mode-setup ()
        "Basic Go mode setup."
      (add-hook 'before-save-hook #'lsp-format-buffer t t)
      (add-hook 'before-save-hook #'lsp-organize-imports t t))
      (add-hook 'go-mode-hook #'my/go-mode-setup))

    (use-package lsp-mode
      :ensure t
      :commands (lsp lsp-mode lsp-deferred)
      :hook ((rust-mode python-mode go-mode) . lsp-deferred)
      :config
      (setq lsp-prefer-flymake nil
            lsp-enable-indentation nil
            lsp-enable-on-type-formatting nil
            lsp-rust-server 'rust-analyzer)
      ;; for filling args placeholders upon function completion candidate selection
      ;; lsp-enable-snippet and company-lsp-enable-snippet should be nil with
      ;; yas-minor-mode is enabled: https://emacs.stackexchange.com/q/53104
      (lsp-modeline-code-actions-mode)
      (add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration))
  #+end_src
** Erlang
#+BEGIN_SRC emacs-lisp
(add-hook 'erlang-mode-hook '(lambda() (setq indent-tabs-mode nil)))
#+END_SRC
** JS
   Tide is the way to go, even for JS (non TS). Played around with Tern, could not get some setup working.
#+BEGIN_SRC emacs-lisp
  (defun js-mode-addons ()
    ; start tide
    (tide-setup)
    ; flycheck config
    (flycheck-add-next-checker 'javascript-eslint 'javascript-tide 'append)
    (flycheck-mode +1)
    ;; use local eslint if possible
    (cg/use-eslint-from-node-modules)
    ; eldoc config
    (eldoc-mode +1)
    ; autocomplete
    (company-mode +1)
    ; tide formatting settings
    ;(setq tide-format-options '(:indentSize 2 :tabSize 2 :convertTabsToSpaces true))
    ; formatting
    (add-hook 'before-save-hook 'tide-format-before-save)
    ; better eldoc looks
    (require 'eldoc-box)
    (eldoc-box-hover-mode)
    ;; enable dash docsets
    (setq-local helm-dash-docsets '("Express"))
  )

  (add-hook 'js-mode-hook #'js-mode-addons)
#+END_SRC

  Use local eslint instead of global. Sourced from: https://emacs.stackexchange.com/a/21207
#+BEGIN_SRC emacs-lisp
(defun cg/use-eslint-from-node-modules ()
  (let* ((root (locate-dominating-file
                (or (buffer-file-name) default-directory)
                "node_modules"))
         (eslint
          (and root
               (expand-file-name "node_modules/.bin/eslint"
                                 root))))
    (when (and eslint (file-executable-p eslint))
      (setq-local flycheck-javascript-eslint-executable eslint))))
#+END_SRC
** Docker
#+BEGIN_SRC emacs-lisp
(use-package kubernetes
  :ensure t
  :hook ((docker-image-mode-hook docker-container-mode-hook docker-volume-mode-hook docker-network-mode-hook)
         . 'evil-emacs-state))
#+END_SRC
** Kubernetes

   Install k8s porcelain in the style of magit.
#+BEGIN_SRC emacs-lisp
(use-package kubernetes
  :ensure t
  :commands (kubernetes-overview))

;; If you want to pull in the Evil compatibility package.
(use-package kubernetes-evil
  :ensure t
  :after kubernetes)
#+END_SRC

 TODO Move to using use-package hook.
#+BEGIN_SRC emacs-lisp
(add-hook 'kubernetes-overview-mode-hook 'evil-emacs-state)
#+END_SRC
** Java
#+BEGIN_SRC emacs-lisp
(use-package lsp-java
  :ensure t)

(defun java-mode-addons ()
  ; path to java lsp server
  (setq lsp-java-server-install-dir "~/thirdparty/eclipse.jdt.ls/org.eclipse.jdt.ls.product/target/repository/")
  (lsp-ui-mode)
  (lsp)
  ; disable sideline -> not using the actions really
  (lsp-ui-sideline-mode -1)
  ; disable popup doc (too big for my screen), we see the doc in the minibuffer anyway
  (lsp-ui-doc-mode -1)
  ; company
  (company-mode +1)
)

(add-hook 'java-mode-hook #'java-mode-addons)
#+END_SRC
** Anisble
   Define a `task` text object.
#+BEGIN_SRC emacs-lisp
  (evil-define-text-object evil-i-ansible-task (count &optional beg end type)
     (evil-range (save-excursion
                     (end-of-line)
                     (search-backward "- name:")
                     (point))
                 (save-excursion
                     ; TODO: does not work with nested tasks like blocks
                     (search-forward "- name:" nil 'move)
                     (forward-line -1)
                     (while (looking-at "[[:space:]]*$")
                       (forward-line -1))
                     (end-of-line)
                     (point))
                 ; force line-wise mode
                 'line))
#+END_SRC

  Imenu based on task names.
#+BEGIN_SRC emacs-lisp
(defun setup-ansible-task-imenu ()
  ; match "- name: ..." lines
  (setq imenu-generic-expression '(("tasks" "^[[:space:]]*-[[:space:]]name:[[:space:]]\\(.*\\)$" 1))))
#+END_SRC

  Special action to add/remove the tag "curr" to the selected task. Used for easy testing of tasks.
  Currently this assumes a single task object, that is, it only works with the "t" object defined above.
#+BEGIN_SRC emacs-lisp
  ; for string manipulation
  (require 's)

  (evil-define-operator evil-ansible-tagging (beg end type)
    (interactive "<R>")
    (save-excursion
      ; check if tag occurs inside the section
      (if (not (save-excursion (search-forward "tags:" end t)))
         ; no tags entry found, add one with "curr"
         (progn
            (end-of-line)
            (open-line 1)
            (forward-line)
            (insert "tags: [curr]")
            (indent-according-to-mode))
         ; a tags entry was found, check if it's a single [curr]
         (if (search-forward "tags: [curr]" end t)
            ; a single curr tag, implying we have added it, now remove it
            ; TODO: this impacts the kill ring, need a better method
            (kill-whole-line)
            ; else, a tags entry already exists with other tags
            (progn
               ; get to the tags line and extract the string inside []
               (re-search-forward "tags: \\[\\(.*\\)\\]" end)
               (let* ((taglist (s-split ", " (match-string-no-properties 1)))) ; convert to a list of strings
                  ; if curr is in taglist
                  (if (member "curr" taglist)
                    ; remove it
                    (delete "curr" taglist)
                    ; or add it - to the end
                    (add-to-list 'taglist "curr" t))
                  ; join them back and replace into the substring
                  (replace-match (s-join ", " taglist) nil nil nil 1)))))))
#+END_SRC

  Special operator to get task name.
#+BEGIN_SRC emacs-lisp
  (evil-define-operator evil-ansible-get-task-name (beg end type)
    (interactive "<R>")
    (save-excursion
       (re-search-forward "name: \\(.*\\)$" end)
       (kill-new (match-string-no-properties 1))))
#+END_SRC

Manually setup ansible mode.
#+BEGIN_SRC emacs-lisp
    (defun ansible-mode ()
      (interactive)
      ; base yaml mode
      (yaml-mode)
      ; task text object
      (define-key evil-inner-text-objects-map "t" 'evil-i-ansible-task)
      (define-key evil-outer-text-objects-map "t" 'evil-i-ansible-task)
      ; enable task imenu
      (setup-ansible-task-imenu)
      ; easily toggle "curr" tag
      (evil-define-key 'operator global-map "gt" 'evil-ansible-tagging)
      (define-key evil-normal-state-map "gt" 'evil-ansible-tagging)
      (evil-define-key 'operator global-map "gn" 'evil-ansible-get-task-name)
      (define-key evil-normal-state-map "gn" 'evil-ansible-get-task-name)
  )
#+END_SRC
** Common Lisp
   Just use sbcl.
   #+begin_src emacs-lisp
   (setq inferior-lisp-program "sbcl")
   #+end_src

   Better key bindings:
   #+begin_src emacs-lisp
     (evil-define-key 'normal 'lisp-mode-map (kbd "'x") 'slime-eval-defun)
     (evil-define-key 'normal 'lisp-mode-map (kbd "'e") 'slime-eval-last-expression)
   #+end_src
** PlantUMML
   #+begin_src emacs-lisp
(setq plantuml-jar-path "~/bin/plantuml.jar")
(setq plantuml-default-exec-mode 'jar)
   #+end_src
** Lisp
  Enable parinfer for all Lisps.
#+begin_src emacs-lisp
(use-package parinfer-rust-mode
  :hook lisp-mode scheme-mode)
#+end_src
* Iron Helm of Dexterity [4, +5] (+3)
  Install Helm.
#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :config
  (helm-mode 1))
#+END_SRC

  Bindings for M-x for evil and for all other modes (primarily exwm).
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map " " 'helm-M-x)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
  (exwm-input-set-key (kbd "s-SPC") 'helm-M-x)
#+END_SRC

 DOES NOT WORK
 Getting helm into a separate frame.
#+BEGIN_SRC emacs-lisp
  ;; (setq helm-display-function 'helm-display-buffer-in-own-frame
  ;;         helm-display-buffer-reuse-frame t
  ;;         helm-use-undecorated-frame-option t)
#+END_SRC

 NOT TESTED
#+BEGIN_SRC emacs-lisp
  ;;https://www.reddit.com/r/emacs/comments/bsc8pc/why_did_you_stop_using_helm/eomanzl?utm_source=share&utm_medium=web2x
  ;; (require 'dash)

  ;; (define-advice helm-display-buffer-popup-frame (:around (f buffer frame-alist) tweak-appearance)
  ;;   (funcall f buffer
  ;;            (-reduce-from (lambda (alist pair) (cons pair alist))
  ;;                          frame-alist
  ;;                          ;; Overriding frame parameters for initial creation.
  ;;                          '((fullscreen . nil)
  ;;                            (left-fringe . 8)
  ;;                            (right-fringe . 8)
  ;;                            (border-width . 0)
  ;;                            (unsplittable . t)
  ;;                            (undecorated . t)
  ;;                            (cursor-type . bar))))

  ;;   (when helm-popup-frame
  ;;     (any-customization-here)
  ;;     ;; FIX: Make helm support dynamic sizing instead.
  ;;     (setq helm-display-buffer-width (frame-width helm-popup-frame)
  ;;           helm-display-buffer-height (frame-height helm-popup-frame))))

#+END_SRC

** Buffer switching
  Section for various buffer switch configurations.
  
  Helm mini.
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "C-y") 'helm-mini)
  (define-key evil-emacs-state-map (kbd "C-y") 'helm-mini)
#+END_SRC

  Kill buffer in-line from ~helm-mini~:
#+begin_src emacs-lisp
  (define-key helm-buffer-map (kbd "`") 'helm-buffer-run-kill-persistent)
#+end_src

 Using `helm-ls-git` to get open buffers in current git project. Haven't found myself using this at all.
#+BEGIN_SRC emacs-lisp
  (setq helm-ls-git-default-sources '(helm-source-ls-git-buffers))
  ;(define-key evil-normal-state-map (kbd "C-e") 'helm-ls-git-ls)
#+END_SRC

 Bespoke helm command for accessing any file in git project.
#+BEGIN_SRC emacs-lisp
  (defun cg-helm-git-ls-files ()
    (interactive)
    (helm :sources (helm-build-in-buffer-source "cg-helm-git-ls-file-source"
                     :init (lambda ()
                             (with-current-buffer (helm-candidate-buffer 'global)
                               (call-process-shell-command
                                "cd $(git rev-parse --show-toplevel); git ls-files --exclude-standard"
                                nil t)))
                     :action (lambda (candidate)
                                    (find-file (concat (string-trim (shell-command-to-string "git rev-parse --show-toplevel"))
                                                        "/"
                                                        candidate))))
          :buffer "*helm git ls-files*"))
  (define-key evil-normal-state-map (kbd "C-p") 'cg-helm-git-ls-files)
#+END_SRC

 Switch easily between locations.
 #+begin_src emacs-lisp
   (use-package consult-dir
     :ensure t
     :bind (("C-x C-d" . consult-dir))
     :config (define-key evil-normal-state-map (kbd "C-d") 'consult-dir))
 #+end_src

** In Buffer switching

  Imenu. Search in current buffer.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-i") 'helm-semantic-or-imenu)
#+END_SRC

  Imenu anywhere. Install `imenu-anywhere`.
#+BEGIN_SRC emacs-lisp
(use-package imenu-anywhere
  :ensure t)
(define-key evil-normal-state-map (kbd "C-e") 'helm-imenu-anywhere)
#+END_SRC
** Window switching

  For switching exwm windows.
  You can only switch within a workspace, so the switcher filters in only windows present in the current workspace.
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
  (defun helm-exwm-current-workspace ()
    (interactive)
    (helm-exwm (function
                (lambda ()
                  (if (eq exwm--desktop (exwm-workspace--position exwm-workspace--current)) t nil)))))

  (exwm-input-set-key (kbd "s-y") 'helm-exwm-current-workspace)
#+END_SRC

  For jumping to exwm windows irrespective of workspace.
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
  (exwm-input-set-key (kbd "M-y") (lambda ()
                    (interactive)
                    (exwm-workspace-switch-to-buffer (helm-exwm))))
#+END_SRC
* Say NO to RSI
  General key bindings.

  Swap meta and super. Mostly a backward compatibility thing from the days of dwm. Keeping it for now.
#+BEGIN_SRC emacs-lisp
(setq x-meta-keysym 'super)
(setq x-super-keysym 'meta)
#+END_SRC

  Add "emacs-lisp" code block template.
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
#+END_SRC

  Super simplified window switching:
  #+begin_src emacs-lisp
    (define-key evil-normal-state-map (kbd "!`") 'delete-other-windows)
    (define-key evil-normal-state-map (kbd "!@") 'split-window-below)
    (define-key evil-normal-state-map (kbd "!#") 'split-window-right)
    (define-key evil-normal-state-map (kbd "!q") 'delete-window)
    (define-key evil-normal-state-map (kbd "!!") 'other-window)
  #+end_src

  One shot keys for the important ones.
  This approach is a massive hack. Unfortunately, the cleaner options don't seem to work due to the way prefix keys work in emacs.
  #+begin_src emacs-lisp
    ; see if we can manipulate the events variable - instead of setting it appending to it after removing items?
    (defmacro single-prefix-key (map key orig)
      `(define-key ,map (kbd ,key) (lambda ()
                               (interactive)
                               (setq unread-command-events
                                     (listify-key-sequence (kbd ,orig))))))

    (single-prefix-key evil-normal-state-map "," "C-c")

    ; what to do about this? very ugly and won't work for one more level of nesting
    (single-prefix-key evil-normal-state-map "C-c ," "C-c C-c")
    (single-prefix-key mode-specific-map "C-h" "C-c C-h")

    (single-prefix-key ctl-x-map "," "C-x C-c")
    (single-prefix-key help-map "," "C-h C-c")
    (single-prefix-key mode-specific-map "," "C-c C-c")

    (single-prefix-key evil-normal-state-map "-" "C-x")
    (single-prefix-key evil-normal-state-map "\\" "C-h")
   #+end_src

* EXWM: the next step to a Lisp Machine
** Switching workspaces                                            :SOURCEME:

   The default option (for backup).
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
(exwm-input-set-key (kbd "s-w") #'exwm-workspace-switch)
#+END_SRC

   Switch to workspace by num. (Corrected for permenantly toggled number row.)
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
(defun set-exwm-workspace-switch-hotkey (key win-num)
  (exwm-input-set-key (kbd (format "s-%s" key))
		       `(lambda ()
			  (interactive)
			  (exwm-workspace-switch-create ,win-num))))

(set-exwm-workspace-switch-hotkey "!" 1)
(set-exwm-workspace-switch-hotkey "@" 2)
(set-exwm-workspace-switch-hotkey "#" 3)
(set-exwm-workspace-switch-hotkey "$" 4)
(set-exwm-workspace-switch-hotkey "%" 5)
(set-exwm-workspace-switch-hotkey "^" 6)
(set-exwm-workspace-switch-hotkey "&" 7)
(set-exwm-workspace-switch-hotkey "*" 8)
(set-exwm-workspace-switch-hotkey "(" 9)
(set-exwm-workspace-switch-hotkey ")" 0)
#+END_SRC

   Alt-Tab behaviour.
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
(defvar exwm-workspace-previous-index nil "The previous active workspace index.")

(defun update-last-workspace (_x)
  (setq exwm-workspace-previous-index exwm-workspace-current-index))
; fails if sourced at bootup, works otherwise
;(advice-add 'exwm-workspace-switch :before 'update-last-workspace)

(defun exwm-workspace-switch-to-previous ()
  "Switch to the previous active workspace." 
  (interactive)
  (let ((index exwm-workspace-previous-index))
    (exwm-workspace-switch index)))

(exwm-input-set-key (kbd "<s-tab>") #'exwm-workspace-switch-to-previous)
#+END_SRC

** Launching Applications
   Launch generic system application async.
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
; Launch application
(exwm-input-set-key (kbd "s-p")
		    (lambda (command)
		      (interactive (list (read-shell-command "$ ")))
		      (start-process-shell-command command nil command)))
#+END_SRC  

   For one-off shell commands.
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
(exwm-input-set-key (kbd "s-P") 'shell-command)
#+END_SRC 

** Visual cues                                                     :SOURCEME:
   
   Display dwm like bar in mini-buffer.
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
; function to generate contents of bar
(defun exwm-workspace-listing-minibuffer (_x)
  (message (mapconcat (lambda (x)
			(format (if (= x exwm-workspace-current-index) "[%d]" "%d") x))
		      (append (number-sequence 1 9) '(0))
		      " ")))

; refresh upon switch
; careful: crashes on bootup if un-commented
;(advice-add 'exwm-workspace-switch :after #'exwm-workspace-listing-minibuffer)
#+END_SRC
** Dynamic Window Management
   
   Switch to last buffer in window. Maybe can be replaced with `evil-buffer`?
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
(defun switch-to-previous-buffer ()
  "Switch to previously open buffer.
Repeated invocations toggle between the two most recently open buffers."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1) t))

(global-set-key (kbd "C-c b") 'switch-to-previous-buffer)
(global-set-key (kbd "<C-tab>") 'switch-to-previous-buffer)
#+END_SRC

  Easier management of common Emacs window actions.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-!") 'delete-other-windows)
(global-set-key (kbd "C-@") 'split-window-below)
(global-set-key (kbd "C-#") 'split-window-right)
(global-set-key (kbd "C-`") 'delete-window)
(global-set-key (kbd "C-$") 'other-window)
#+END_SRC

  Dwm like (for a very loose meaning of like) window resizing. Operates on the current focused window.
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
(exwm-input-set-key (kbd "s-k") 'enlarge-window)
(exwm-input-set-key (kbd "s-j") 'shrink-window)
(exwm-input-set-key (kbd "s-l") 'enlarge-window-horizontally)
(exwm-input-set-key (kbd "s-h") 'shrink-window-horizontally)
#+END_SRC
** Assorted QoL changes
   
   Reload .emacs.
#+BEGIN_SRC emacs-lisp
(defun cg/reinit ()
  (interactive)
  (load-file "~/.emacs"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
(exwm-input-set-key (kbd "s-R") 'cg/reinit)
#+END_SRC

   Better names for windows.
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
(add-hook 'exwm-update-title-hook
	  (lambda ()
	    (exwm-workspace-rename-buffer exwm-title)))
#+END_SRC
** Application specific mappings
*** Firefox
    In the pre-Quantum Firefox days, used to use VimFx. That is gone now.
    Almost all "Vim-like" extensions for Firefox are slow, bloated and require a bunch of permissions.

    So, we use our Lisp machine instead.
    TODO: need to figure out a system for single key shortcuts.
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
(add-hook 'exwm-manage-finish-hook
          (lambda ()
            (when (and exwm-class-name
                       (string= exwm-class-name "Firefox"))
              (exwm-input-set-local-simulation-keys
	      '(([?\C-d] . []))))))
#+END_SRC

    TODO: Look into walseb/exwm-firefox-evil
*** Network Manager

    Some settings (like VPN) are only configurable through nm-applet. nmtui/nmcli don't work in this context.
#+BEGIN_SRC emacs-lisp
  (defvar is-network-tools-open nil "Current status of network tools.")

  (defun toggle-network-tools ()
    (interactive)
    (if is-network-tools-open
      (progn
       (setq is-network-tools-open nil)
       (start-process-shell-command "Tray" nil "trayer --edge left --height 42 --widthtype request --distance 10 --transparent true --alpha 127 --tint 0x55556666 --padding 10")
       (start-process-shell-command "NMApplet" nil "nm-applet"))
      (progn
       (setq is-network-tools-open t)
       (start-process-shell-command "CloseTray" nil "pkill trayer")
       (start-process-shell-command "CloseNMApplet" nil "pkill nm-applet"))))

  (global-set-key (kbd "M-w") 'toggle-network-tools)
#+END_SRC
* General system management
  Manage init systems.
#+BEGIN_SRC emacs-lisp
(use-package daemons
  :ensure daemons
  :requires s)
#+END_SRC

  Lock/Suspend system. For Emacs buffers and for EXWM windows.
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
(define-key exwm-mode-map (kbd "<f9>") (lambda ()
                                  (interactive)
                                  (start-process-shell-command "rlock" nil "rlock")))

(define-key exwm-mode-map (kbd "<f10>") (lambda ()
                                   (interactive)
                                   (start-process-shell-command "sleeplock" nil "sudo pm-suspend; slock")))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f9>") (lambda ()
                                  (interactive)
                                  (start-process-shell-command "rlock" nil "rlock")))

(global-set-key (kbd "<f10>") (lambda ()
                                   (interactive)
                                   (start-process-shell-command "sleeplock" nil "sudo pm-suspend; slock")))
#+END_SRC
* Shells and Terminals
  
  Normal shell.
  TODO Maintain a map of shells to projects and somehow bring up the right shell for each project. 
  This causes problems with multiple shells per project. So, each project needs a single primary shell and other
  named shells perhaps...
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
(exwm-input-set-key (kbd "M-`") 'shell)
(exwm-input-set-key (kbd "M-!") (lambda ()
                                  (interactive)
                                  (let ((b (generate-new-buffer "*shell*")))
                                    (shell b))))
#+END_SRC

  Bring up and dismiss terminals.
  (Without clobbering history).

  New terminals. Works only from Emacs buffers.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f5>") 'cg/open-terminal)
(global-set-key (kbd "<f6>") 'cg/open-vterm-frame)
#+END_SRC

  Tramp aware terminal. If current buffer is remote, open st and ssh. If not, simply open st.
#+begin_src emacs-lisp
(defun cg/open-terminal ()
  (interactive)
  (let* ((curr-dir default-directory)
         (is-remote (s-prefix? "/ssh:" curr-dir))
         )
    (if (not is-remote)
      (start-process-shell-command "vex" nil "vex")
      (let* ((parts (split-string curr-dir ":"))
             (node (nth 1 parts))
             (wd (nth 2 parts)))
        ;; NOTE: does not cd to wd yet
        (start-process-shell-command "st" nil (concat "st -e ssh " node))))))
#+end_src

#+begin_src emacs-lisp
  (defun cg/open-vterm-frame ()
    (interactive)
    (with-selected-frame (make-frame '((internal-border-width . 10)))
      (vterm)))
#+end_src
** Better Shell
   How do we best use shells inside Emacs?
   What are the options and the problems with them?

   1. ~shell~
      1. Tab autocomplete does not work.
   2. ~ansi-term~ with bash
      1. Throws an error everytime it sees Bash color codes.
   3. ~term~ with bash
      1. Same as 2.1
   4. ~eshell~
      1. "C-l" for clear does not work.
      2. Looks like "~/.bashrc" is not evaled, custom aliases and shortcuts not available.
      3. History comes from some strange place, not the bash history.
      4. File tab completion is a bit strange due to completion hint popping in a separate split. However, the key focus is still in the prompt line, so that's good.
      5. Interrupting requires a double `C-c` now, instead of a single one.
      6. ~source~ seems to expect elisp files to source, not bash scripts. (*Maybe be unsolvable*: https://superuser.com/questions/273273/how-to-source-a-bash-script-in-emacs-eshell)

   ~vterm~ may solve all of these problems, in pieces.
** vterm
   Evil object for an entire input/output section in vterm.
   
   #+begin_src emacs-lisp
(evil-define-text-object evil-vterm-command (count &optional beg end type)
     (evil-range (save-excursion
                   (vterm-previous-prompt 1) (point))
                 (save-excursion
                   (vterm-next-prompt 1) (forward-line -1) (point))
                 ; force line-wise mode
                 'line))

  (define-key evil-outer-text-objects-map "c" 'evil-vterm-command)
   #+end_src

   Direct output to vterm. Adapted from:
   https://www.reddit.com/r/emacs/comments/op4fcm/send_command_to_vterm_and_execute_it/
   #+begin_src emacs-lisp
     (defun cg/vterm-execute-region-or-current-line ()
       "Insert text of current line in vterm and execute."
       (interactive)
       (require 'vterm)
       (eval-when-compile (require 'subr-x))
       (let ((command (if (region-active-p)
                          (string-trim (buffer-substring
                                        (save-excursion (region-beginning))
                                        (save-excursion (region-end))))
                        (string-trim (buffer-substring (save-excursion
                                                         (beginning-of-line)
                                                         (point))
                                                       (save-excursion
                                                         (end-of-line)
                                                         (point)))))))
         (save-excursion
           (unless (get-buffer vterm-buffer-name)
             (vterm))
           (with-current-buffer vterm-buffer-name
             (vterm--goto-line -1)
             (message command)
             (vterm-send-string command)
             (vterm-send-return)))))

     (global-set-key "\C-cv" 'cg/vterm-execute-region-or-current-line)
   #+end_src

   #+RESULTS:
   : cg/vterm-execute-region-or-current-line

* Assorted QoL changes
  Save buffers automatically when possible.
#+BEGIN_SRC emacs-lisp
;; runs on tab switch etc
;; only runs on buffers with non nil file-name which is true for all user buffers
;; special/system buffers (all surrounded with **) such as *scratch*, *ielm* etc are not saved
(add-hook 'focus-out-hook (lambda ()
			    (interactive)
			    (if (not (equal (buffer-file-name) nil))
				    (save-buffer)
				  )))
#+END_SRC

  Set browser to use for opening.
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-generic
            browse-url-generic-program "firefox")
#+END_SRC

  Set backups file name.
#+BEGIN_SRC emacs-lisp
(defun make-backup-file-name (filename)
  (expand-file-name
    (concat "." (file-name-nondirectory filename) "~")
    (file-name-directory filename)))
#+END_SRC

  Flash expression evaluations. TODO Need a better option than rebinding the core eval key.
#+BEGIN_SRC emacs-lisp
(use-package eval-sexp-fu
  :ensure t
  :config 
  (turn-on-eval-sexp-fu-flash-mode)
  :bind (("C-x C-e" . eval-sexp-fu-eval-sexp-inner-list)))
#+END_SRC

  Enable autoreloads of files.
  #+begin_src emacs-lisp
(global-auto-revert-mode t)
  #+end_src

* Custom Workflows
** Single Org file Blog generator

#+BEGIN_SRC emacs-lisp
(defvar cg/blog-output-folder "~/Sites/main/blog")

(defmacro cg/blog-get-heading-text ()
  '(org-no-properties (org-get-heading t t t t)))

(defmacro cg/blog-heading-publishable-p ()
  '(let* ((heading-components (org-heading-components))
          (lvl (nth 0 heading-components))
          (todo (nth 2 heading-components)))
     (and (eq lvl 3) (eq todo nil))))

(defun cg/blog-process-entry (dir)
  "Deal with the blog posts."
  (if (cg/blog-heading-publishable-p)
    (let* ((output (concat dir "/" (replace-regexp-in-string " " "-" (cg/blog-get-heading-text)) ".html"))
           (date (org-entry-get (point) "SCHEDULED"))
           (tags (org-get-tags))
           (preamble (concat
                        "<span><a href=\"../../\">Top</a></span>"
                        "<span style=\"float:right;\"><a href=\"../../../\">Home</a></span>"
                        "<hr/>"
                        "<span class=\"org-src-container\">" date "</span>"
                        "<span style=\"float:right;\" class=\"tag\">"
                        (mapconcat (lambda (tag)
                                     (concat "<a href=\"../../tags/" tag ".html\">"
                                             "<span class=\"" tag "\">" tag "</span></a>"))
                           tags "")
                        "</span>"
                        )))
      ; add preamble with date, tags etc
      (setq org-html-preamble-format `(("en" ,preamble)))
      ; export and save file in the right place
      (rename-file (org-html-export-to-html nil t) output t)
      ; also add to mapping of posts to paths
      (push `(,(cg/blog-get-heading-text) ,(s-chop-prefix cg/blog-output-folder output) ,date) name-to-path))))

(defun cg/blog-delve-toplevel ()
  "Deal with years."
  (cg/blog-delve 1 cg/blog-output-folder cg/blog-delve-secondlevel))

(defun cg/blog-delve-secondlevel (dir)
  "Deal with months."
  (cg/blog-delve 2 dir cg/blog-process-entry))

(defmacro cg/blog-delve (level dir func)
  "At some level of the heading tree, create folder and delve - running func at each immediate subheading."
  `(if (eq ,level (nth 0 (org-heading-components)))
    (let ((nextdir (concat ,dir "/" (cg/blog-get-heading-text))))
      (mkdir nextdir t)
      (org-map-tree (lambda () (,func nextdir))))))

(defun cg/blog-extract-posts-with-tags ()
  "Used in cg/blog-generate-tag-listing to convert relevent headings to information needed for tag mgmt."
  (let* ((comps (org-heading-components))
          (lvl (nth 0 comps))
          (todo (nth 2 comps))
          (hdline (nth 4 comps))
          (tags (nth 5 comps)))
      (if (and (eq 3 lvl) (eq nil todo))
        `(,hdline ,tags))))

(defun cg/blog-generate-tag-listing ()
  "Create a html page for each tag, with links to posts under the tag."
  (mkdir (concat cg/blog-output-folder "/tags") t)
  (setq post-tag-mapping (remove nil (org-map-entries 'cg/blog-extract-posts-with-tags t 'file)))
  ; obtain the heading to tags mapping
  (let ((basedir (concat cg/blog-output-folder "/tags"))
        (all-tags (-flatten (org-get-buffer-tags))))
     (mkdir basedir t)
     ;; build up main index
     (with-temp-file (concat basedir "/all.html")
         (insert (concat "<h1>All posts</h1>"))
         (insert "<ul>")
         (mapc (lambda (x)
                 (let* ((title (nth 0 x))
                        (metadata (assoc title name-to-path))
                        (path (nth 1 metadata))
                        (date (nth 2 metadata)))
                   (insert (concat "<li>" date "<a href=.." path ">" title "</a></li>")))) post-tag-mapping)
         (insert "</ul>")
     )
     (dolist (tag all-tags)
       ; process each tag sequentially
       (with-temp-file (concat basedir "/" tag ".html")
         (insert (concat "<h1>Posts tagged: " tag "</h1>"))
         (insert "<ul>")
         (mapc (lambda (x)
                  (let* ((title (nth 0 x))
                         (tags (nth 1 x))
                         (taglist (s-split ":" tags)))
                     (if (member tag taglist)
                        (let* ((metadata (assoc title name-to-path))
                               (path (nth 1 metadata))
                               (date (nth 2 metadata)))
                            (insert (concat "<li>"
                                            date
                                            "<a href=.."
                                            path
                                            ">" title "</a></li>")))))) post-tag-mapping)
         (insert "</ul>")
         ))
))

(defun cg/blog-generate-entry-page ()
  "Create an entry page."
  (let ((all-tags (-flatten (org-get-buffer-tags)))
        (recent-posts (reverse (nthcdr (- (length post-tag-mapping) 10) post-tag-mapping)))
       )
    (with-temp-file (concat cg/blog-output-folder "/index.html")
        (insert "<h1>Blog</h1>")

        (insert "View by Tag: ")
        (dolist (tag (push "all" all-tags))
            (insert (concat "<a href=tags/" tag ".html> " tag "</a>")))
        (insert "<hr/>")

        (insert "<h2>Recent Posts:</h2>")
        (mapc (lambda (x)
                 (let* ((title (nth 0 x))
                        (metadata (assoc title name-to-path))
                        (path (nth 1 metadata))
                        (date (nth 2 metadata)))
                   (insert (concat "<li>" date "<a href=." path ">" title "</a></li>")))) recent-posts)
    )
  ))

(defun cg/blog-export ()
  "Generate blog from an orgmode file. Top 2 level headings are assumed to be Year/Month."
  ; alist from post title to filepath
  (setq name-to-path '())
  (setq post-tag-mapping '())
  ;Export 3rd level subtrees into individual files and the ones above as folders.
  (org-map-entries 'cg/blog-delve-toplevel t 'file)
  ; generate tag -> post indexes
  (cg/blog-generate-tag-listing)
  ; generate main page -> containing recent posts and pointers to the tag pages
  (cg/blog-generate-entry-page))

#+END_SRC
*** Trying to make the ouput deterministic

    Taking care of html IDs and anchors. From: https://github.com/alphapapa/unpackaged.el#export-to-html-with-useful-anchors
#+BEGIN_SRC emacs-lisp
(define-minor-mode unpackaged/org-export-html-with-useful-ids-mode
  "Attempt to export Org as HTML with useful link IDs.
Instead of random IDs like \"#orga1b2c3\", use heading titles,
made unique when necessary."
  :global t
  (if unpackaged/org-export-html-with-useful-ids-mode
      (advice-add #'org-export-get-reference :override #'unpackaged/org-export-get-reference)
    (advice-remove #'org-export-get-reference #'unpackaged/org-export-get-reference)))

(defun unpackaged/org-export-get-reference (datum info)
  "Like `org-export-get-reference', except uses heading titles instead of random numbers."
  (let ((cache (plist-get info :internal-references)))
    (or (car (rassq datum cache))
        (let* ((crossrefs (plist-get info :crossrefs))
               (cells (org-export-search-cells datum))
               ;; Preserve any pre-existing association between
               ;; a search cell and a reference, i.e., when some
               ;; previously published document referenced a location
               ;; within current file (see
               ;; `org-publish-resolve-external-link').
               ;;
               ;; However, there is no guarantee that search cells are
               ;; unique, e.g., there might be duplicate custom ID or
               ;; two headings with the same title in the file.
               ;;
               ;; As a consequence, before re-using any reference to
               ;; an element or object, we check that it doesn't refer
               ;; to a previous element or object.
               (new (or (cl-some
                         (lambda (cell)
                           (let ((stored (cdr (assoc cell crossrefs))))
                             (when stored
                               (let ((old (org-export-format-reference stored)))
                                 (and (not (assoc old cache)) stored)))))
                         cells)
                        (when (org-element-property :raw-value datum)
                          ;; Heading with a title
                          (unpackaged/org-export-new-title-reference datum cache))
                        ;; NOTE: This probably breaks some Org Export
                        ;; feature, but if it does what I need, fine.
                        (org-export-format-reference
                         (org-export-new-reference cache))))
               (reference-string new))
          ;; Cache contains both data already associated to
          ;; a reference and in-use internal references, so as to make
          ;; unique references.
          (dolist (cell cells) (push (cons cell new) cache))
          ;; Retain a direct association between reference string and
          ;; DATUM since (1) not every object or element can be given
          ;; a search cell (2) it permits quick lookup.
          (push (cons reference-string datum) cache)
          (plist-put info :internal-references cache)
          reference-string))))

(defun unpackaged/org-export-new-title-reference (datum cache)
  "Return new reference for DATUM that is unique in CACHE."
  (cl-macrolet ((inc-suffixf (place)
                             `(progn
                                (string-match (rx bos
                                                  (minimal-match (group (1+ anything)))
                                                  (optional "--" (group (1+ digit)))
                                                  eos)
                                              ,place)
                                ;; HACK: `s1' instead of a gensym.
                                (-let* (((s1 suffix) (list (match-string 1 ,place)
                                                           (match-string 2 ,place)))
                                        (suffix (if suffix
                                                    (string-to-number suffix)
                                                  0)))
                                  (setf ,place (format "%s--%s" s1 (cl-incf suffix)))))))
    (let* ((title (org-element-property :raw-value datum))
           (ref (url-hexify-string (substring-no-properties title)))
           (parent (org-element-property :parent datum)))
      (while (--any (equal ref (car it))
                    cache)
        ;; Title not unique: make it so.
        (if parent
            ;; Append ancestor title.
            (setf title (concat (org-element-property :raw-value parent)
                                "--" title)
                  ref (url-hexify-string (substring-no-properties title))
                  parent (org-element-property :parent parent))
          ;; No more ancestors: add and increment a number.
          (inc-suffixf ref)))
      ref)))
#+END_SRC

    Source this and be sure to enable the minor mode in the actual blog source org file.

    There are other options discussed here: https://www.reddit.com/r/orgmode/comments/aagmfh/export_to_html_with_useful_nonrandom_ids_and/
    Need to consider and replace the above if a simple option is available.
#+RESULTS:
: unpackaged/org-export-new-title-reference

* Beauty is in the eye of the beholder
  Disable menu bar and tool bar.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode 0)
(tool-bar-mode 0)
#+END_SRC

  Disable scroll bar.
#+BEGIN_SRC emacs-lisp
(scroll-bar-mode 0)
#+END_SRC

  Disable fringe.
#+BEGIN_SRC emacs-lisp
(fringe-mode '(0 . 0))
#+END_SRC

  Set frame format for dwm to pick up for the smart key (smart-prefix).
#+begin_src emacs-lisp
(setq frame-title-format "emacs - %b")
#+end_src

  Make the header-line function as the mode-line. The mode-line is now replaced with a single line.
  #+begin_src emacs-lisp
    (setq-default header-line-format '("%e" mode-line-front-space mode-line-mule-info mode-line-client mode-line-modified mode-line-remote mode-line-frame-identification mode-line-buffer-identification "   " mode-line-position evil-mode-line-tag (vc-mode vc-mode) "  " mode-line-modes mode-line-misc-info mode-line-end-spaces))
    ; use the mode-line as a separator
    (setq-default mode-line-format '(" "))
    (set-face-attribute 'mode-line nil :height 10 :background "black")
    (set-face-attribute 'header-line nil :height 220 :box '(:color "black" :line-width 2) :slant 'italic :background "#F4F4E8")
    (setq x-underline-at-descent-line nil)
  #+end_src

  Set frame padding.
  #+begin_src emacs-lisp
    (add-to-list 'default-frame-alist '(internal-border-width . 10))
  #+end_src

  Enable all-the-icons in dired.
  #+begin_src emacs-lisp
(use-package all-the-icons-dired
  :ensure t
  :hook (dired-mode . all-the-icons-dired-mode)
  :config
  (setq all-the-icons-dired-monochrome nil))
  #+end_src

  Setup color. One time load.
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/exwm.el"
(defvar cg-color-theme-loaded nil)
(if (not cg-color-theme-loaded)
  (progn
    (setq cg-color-theme-loaded t)
    (load-theme 'misterioso t nil)))
#+END_SRC

  Font and size.
#+BEGIN_SRC emacs-lisp
  ;; (set-default-font "-PfEd-Fantasque Sans Mono-normal-normal-normal-*-*-*-*-*-m-0-iso10646-1")
  (add-to-list 'default-frame-alist
    '(font . "-IBM -IBM Plex Mono-regular-normal-normal-*-29-*-*-*-m-0-iso10646-1"))
  (set-face-attribute 'default nil :height 220)
#+END_SRC

  If using Leuven theme, get the headlines size into control. DOES NOT WORK
#+BEGIN_SRC emacs-lisp
(setq leuven-scale-outline-headlines nil)
#+END_SRC

  Good background for light color themes.
#+BEGIN_SRC emacs-lisp
(set-background-color "#F4F4E8")
#+END_SRC
* Configure
    Enable/Disable EXWM. Edit this as needed.
#+BEGIN_SRC emacs-lisp
;;(load "~/.emacs.d/exwm.el")
#+END_SRC
